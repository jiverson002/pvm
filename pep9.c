#include "pep9.h"

/******************************************************************************/
/* Machine types */
/******************************************************************************/
#include <stdint.h>

typedef uint8_t  byte;
typedef uint16_t word;
typedef int8_t   sbyte;
typedef int16_t  sword;

/******************************************************************************/
/* System vectors */
/******************************************************************************/
static word burn_addr = 0x0000;
#define osRAM     (burn_addr - 11)
#define wordTemp  (burn_addr - 9)
#define charIn    (burn_addr - 7)
#define charOut   (burn_addr - 5)
#define loader    (burn_addr - 3)
#define trap      (burn_addr - 1)

/******************************************************************************/
/* Virtual machine structure */
/******************************************************************************/
static struct {
  struct {
    byte nzvc;
    word a;
    word x;
    word pc;
    word sp;
    byte ir;
    word opspec;
  } cpu;

  byte mem[(1 << 16)];
} vm;

#define NZVC   (vm.cpu.nzvc)
#define A      (vm.cpu.a)
#define X      (vm.cpu.x)
#define PC     (vm.cpu.pc)
#define SP     (vm.cpu.sp)
#define IR     (vm.cpu.ir)
#define OpSpec (vm.cpu.opspec)
#define Mem    (vm.mem)

/******************************************************************************/
/* ISA implementation */
/******************************************************************************/
#include <stdio.h>

#if __STDC_VERSION__ < 199901L
  #define inline /* define to nothing if pre-C99 */
#endif

static inline int is_nonunary(byte in_spec) {
  return !((in_spec < 0x12) || (0x27 == (in_spec | 0x01)));
}

static inline byte ldb(word idx) {
  return Mem[idx];
}

static inline word ldw(word idx) {
  return (word)((Mem[idx] << 8) | Mem[idx + 1]);
}

static inline void stb(word idx, byte b) {
  Mem[idx] = b;
}

static inline void stw(word idx, word w) {
  Mem[idx + 0] = (byte)(w >> 8);
  Mem[idx + 1] = (byte)(w & 0x00ff);
}

static inline word add(word a, word b) {
  byte v;
  word c;

  c = a;
  a += b;

  /* Inspect the signs of the numbers and the sum. If you add numbers with
   * different signs, you cannot have an overflow. If you add two numbers with
   * the same sign and the result is not the same sign, then you have signed
   * overflow. */
  v = !((c & 0x8000) ^ (b & 0x8000)) && ((c & 0x8000) ^ (a & 0x8000));

  NZVC = 0;                   /* clear all bits */
  NZVC |= (a >= 0x8000) << 3; /* N */
  NZVC |= (a == 0x0000) << 2; /* Z */
  NZVC |= v << 1;             /* V */
  NZVC |= a < c;              /* C */ /* TODO is this correct */

  return a;
}

static inline word *get_reg(void) {
  return IR <= 0x11
    ? (0x00 == (IR & 0x01) ? &A : &X)
    : (0x00 == (IR & 0x08) ? &A : &X);
}

static inline word get_addr(void) {
  switch (IR & 0x07) {
    case 0x01:  /* direct */
      return OpSpec;
    case 0x02:  /* indirect */
      return ldw(OpSpec);
    case 0x03:  /* stack-relative */
      return SP + OpSpec;
    case 0x04:  /* stack-relative deferred */
      return ldw(SP + OpSpec);
    case 0x05:  /* indexed */
      return OpSpec + X;
    case 0x06:  /* stack-indexed */
      return SP + OpSpec + X;
    case 0x07:  /* stack-deferred indexed */
      return ldw(SP + OpSpec) + X;
    default:    /* error */
      return 0xffff;
  }
}

static inline byte get_byte_oprnd(void) {
  return (0x00 == (IR & 0x07) ? (byte)OpSpec : ldb(get_addr()));
}

static inline word get_word_oprnd(void) {
  return IR <= 0x25
    ? (0x00 == (IR & 0x01) ? OpSpec : ldw(OpSpec + X))
    : (0x00 == (IR & 0x07) ? OpSpec : ldw(get_addr()));
}

static inline void STOP(void) {
}

static void RET(void) {
  PC = ldw(SP);
  SP += 2;
}

static void RETTR(void) {
  NZVC = ldb(SP);
  A = ldw(SP + 1);
  X = ldw(SP + 3);
  PC = ldw(SP + 5);
  SP = ldw(SP + 7);
}

static void MOVSPA(void) {
  A = SP;
}

static void MOVFLGA(void) {
  A &= 0xff00; /* clear A<8..15> */
  A |= NZVC;
}

static void MOVAFLG(void) {
  NZVC = A & 0x000f;
}

static void NOTr(void) {
  word *r = get_reg();

  *r = ~(*r);

  NZVC &= 0x03;                 /* clear all but VC */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
}

static void NEGr(void) {
  word *r = get_reg();

  *r = -(*r);

  NZVC &= 0x01;                 /* clear all but C */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
  NZVC |= (*r == -(*r));        /* V */
}

static void ASLr(void) {
  byte v, c;
  word *r = get_reg();

  /* check if r<0..1> is 01 or 10 */
  v = ((*r < 0x8000) && (*r >= 0x4000)) || ((*r >= 0x8000) && (*r < 0xc000));
  /* check if r<0> is 1 */
  c = *r >= 0x8000;

  *r <<= 1;

  NZVC = 0;                     /* clear all bits */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
  NZVC |= v << 1;               /* Z */
  NZVC |= c;                    /* C */
}

static void ASRr(void) {
  byte c;
  word *r = get_reg();

  /* check if r<15> is 1  */
  c = *r & 0x0001;

  *r = (*r & 0x8000) | (*r >> 1);

  NZVC &= 0x02;                 /* clear all but V */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
  NZVC |= c;                    /* C */
}

static void ROLr(void) {
  byte c;
  word *r = get_reg();

  /* check if r<0> is 1  */
  c = *r >= 0x8000;

  *r = (word)((*r << 1) | (NZVC & 0x0001));

  NZVC &= 0x0e;                 /* clear all but NZV */
  NZVC |= c;                    /* C */
}

static void RORr(void) {
  byte c;
  word *r = get_reg();

  /* check if r<15> is 1  */
  c = *r & 0x0001;

  *r = (word)(((NZVC & 0x0001) << 15) | (*r >> 1));

  NZVC &= 0x0e;                 /* clear all but NZV */
  NZVC |= c;                    /* C */
}

static void BR(void) {
  PC = get_word_oprnd();
}

static void BRLE(void) {
  PC = NZVC & 0x0c ? get_word_oprnd() : PC;
}

static void BRLT(void) {
  PC = NZVC & 0x08 ? get_word_oprnd() : PC;
}

static void BREQ(void) {
  PC = NZVC & 0x04 ? get_word_oprnd() : PC;
}

static void BRNE(void) {
  PC = !(NZVC & 0x04) ? get_word_oprnd() : PC;
}

static void BRGE(void) {
  PC = !(NZVC & 0x08) ? get_word_oprnd() : PC;
}

static void BRGT(void) {
  PC = !(NZVC & 0x0c) ? get_word_oprnd() : PC;
}

static void BRV(void) {
  PC = NZVC & 0x02 ? get_word_oprnd() : PC;
}

static void BRC(void) {
  PC = NZVC & 0x01 ? get_word_oprnd() : PC;
}

static void CALL(void) {
  SP -= 2;
  stw(SP, PC);
  PC = get_word_oprnd();
}

static void LDWr(void) {
  word *r = get_reg();

  *r = get_word_oprnd();

  NZVC &= 0x03;                 /* clear all but VC */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
}

static void LDBr(void) {
  byte oprnd;
  word *r = get_reg();

  switch (IR | 0x08) {
    case 0xd8:  /* immediate */
      oprnd = get_byte_oprnd();
      break;
    default:    /* direct, indirect, stack-relative, stack-relative deferred,
                   indexed, stack-indexed, stack-deferred indexed */
      if (ldw(charIn) == get_addr()) {
        scanf("%c", &oprnd);
      } else {
        oprnd = get_byte_oprnd();
      }
      break;
  }

  *r = (*r & 0xff00) | oprnd;

  NZVC &= 0x03;                 /* clear all but VC */
                                /* N is 0 by definition of Pep/9 */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
}

static void STWr(void) {
  stw(get_addr(), *get_reg());
}

static void STBr(void) {
  byte b = *get_reg() & 0x00ff;
  word op_addr = get_addr();

  if (ldw(charOut) == op_addr) {
    printf("%c", b);
  }
  else {
    stb(op_addr, b);
  }
}

static void ADDSP(void) {
  /* FIXME need to modify NZVC bits */
  SP += get_word_oprnd();
}

static void SUBSP(void) {
  /* FIXME need to modify NZVC bits */
  SP -= get_word_oprnd();
}

static void ADDr(void) {
  word *r = get_reg();

  *r = add(*r, get_word_oprnd());
}

static void SUBr(void) {
  word *r = get_reg();

  *r = add(*r, -get_word_oprnd());
}

static void ANDr(void) {
  word *r = get_reg();

  *r &= get_word_oprnd();

  NZVC &= 0x03;                 /* clear all but VC */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
}

static void ORr(void) {
  word *r = get_reg();

  *r |= get_word_oprnd();

  NZVC &= 0x03;                 /* clear all but VC */
  NZVC |= (*r >= 0x8000) << 3;  /* N */
  NZVC |= (*r == 0x0000) << 2;  /* Z */
}

static void CPWr(void) {
  (void)add(*get_reg(), get_word_oprnd());
}

static void CPBr(void) {
  add((word)(*get_reg() << 8), (word)(((~get_byte_oprnd()) << 8) + 0x0100));
}

static void TRAP(void) {
  word temp = ldb(wordTemp);
  stb(temp - 1, IR);
  stw(temp - 3, SP);
  stw(temp - 5, PC);
  stw(temp - 7, X);
  stw(temp - 9, A);
  stb(temp - 10, NZVC);
  SP = temp - 10;
  PC = ldw(trap);
  X = 0; /* To compensate for a bug in Pep/9 OS, where it should be done. (But
            the book is published already!) */
}

static void (*ops[256])(void) = {
  /* STOP */    STOP,
  /* RET */     RET,
  /* RETTR */   RETTR,
  /* MOVSPA */  MOVSPA,
  /* MOVFLGA */ MOVFLGA,
  /* MOVAFLG */ MOVAFLG,
  /* NOTr */    NOTr, NOTr,
  /* NEGr */    NEGr, NEGr,
  /* ASLr */    ASLr, ASLr,
  /* ASRr */    ASRr, ASRr,
  /* ROLr */    ROLr, ROLr,
  /* RORr */    RORr, RORr,
  /* BR */      BR,   BR,
  /* BRLE */    BRLE, BRLE,
  /* BRLT */    BRLT, BRLT,
  /* BREQ */    BREQ, BREQ,
  /* BRNE */    BRNE, BRNE,
  /* BRGE */    BRGE, BRGE,
  /* BRGT */    BRGT, BRGT,
  /* BRV */     BRV, BRV,
  /* BRC */     BRC, BRC,
  /* CALL */    CALL, CALL,
  /* NOPn */    TRAP, TRAP,
  /* NOP */     TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP,
  /* DECI */    TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP,
  /* DECO */    TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP,
  /* HEXO */    TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP,
  /* STRO */    TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP, TRAP,
  /* ADDSP */   ADDSP, ADDSP, ADDSP, ADDSP, ADDSP, ADDSP, ADDSP,
  /* SUBSP */   SUBSP, SUBSP, SUBSP, SUBSP, SUBSP, SUBSP, SUBSP,
  /* ADDr */    ADDr, ADDr, ADDr, ADDr, ADDr, ADDr, ADDr, ADDr,
                ADDr, ADDr, ADDr, ADDr, ADDr, ADDr, ADDr, ADDr,
  /* SUBr */    SUBr, SUBr, SUBr, SUBr, SUBr, SUBr, SUBr, SUBr,
                SUBr, SUBr, SUBr, SUBr, SUBr, SUBr, SUBr, SUBr,
  /* ANDr */    ANDr, ANDr, ANDr, ANDr, ANDr, ANDr, ANDr, ANDr,
                ANDr, ANDr, ANDr, ANDr, ANDr, ANDr, ANDr, ANDr,
  /* ORr */     ORr, ORr, ORr, ORr, ORr, ORr, ORr, ORr,
                ORr, ORr, ORr, ORr, ORr, ORr, ORr, ORr,
  /* CPWr */    CPWr, CPWr, CPWr, CPWr, CPWr, CPWr, CPWr, CPWr,
                CPWr, CPWr, CPWr, CPWr, CPWr, CPWr, CPWr, CPWr,
  /* CPBr */    CPBr, CPBr, CPBr, CPBr, CPBr, CPBr, CPBr, CPBr,
                CPBr, CPBr, CPBr, CPBr, CPBr, CPBr, CPBr, CPBr,
  /* LDWr */    LDWr, LDWr, LDWr, LDWr, LDWr, LDWr, LDWr, LDWr,
                LDWr, LDWr, LDWr, LDWr, LDWr, LDWr, LDWr, LDWr,
  /* LDBr */    LDBr, LDBr, LDBr, LDBr, LDBr, LDBr, LDBr, LDBr,
                LDBr, LDBr, LDBr, LDBr, LDBr, LDBr, LDBr, LDBr,
  /* STWr */    STWr, STWr, STWr, STWr, STWr, STWr, STWr, STWr,
                STWr, STWr, STWr, STWr, STWr, STWr, STWr, STWr,
  /* STBr */    STBr, STBr, STBr, STBr, STBr, STBr, STBr, STBr,
                STBr, STBr, STBr, STBr, STBr, STBr, STBr, STBr
};

/******************************************************************************/
/* VM API */
/******************************************************************************/
#include <string.h>

static int burn(void *os, unsigned os_len, unsigned addr) {
  if (!os)
    return -1;
  if (os_len > 0x10000)
    return -1;
  if (addr > 0xffff)
    return -1;
  if (addr < os_len)
    return -1;

  /* record burn_addr */
  burn_addr = (word)addr;

  /* load os into memory */
  memcpy(Mem + burn_addr - (os_len - 1), os, os_len);

  return 0;
}

static int init(void) {
  unsigned char default_os[] = {
    0xC8, 0x00, 0x00, 0xD1, 0xFC, 0x15, 0xB0, 0x00, 0x7A, 0x18, 0xFC, 0x51,
    0xB0, 0x00, 0x39, 0x14, 0xFC, 0x2C, 0x60, 0x00, 0x09, 0x0A, 0x0A, 0x0A,
    0x0A, 0xF1, 0xFC, 0x10, 0xD1, 0xFC, 0x15, 0xB0, 0x00, 0x39, 0x14, 0xFC,
    0x3F, 0x60, 0x00, 0x09, 0x80, 0x00, 0x0F, 0x91, 0xFC, 0x0F, 0xF5, 0x00,
    0x00, 0x68, 0x00, 0x01, 0xD1, 0xFC, 0x15, 0x12, 0xFC, 0x1A, 0x00, 0xDB,
    0x00, 0x09, 0xB8, 0x00, 0x28, 0x1C, 0xFC, 0x67, 0x88, 0x00, 0x01, 0x0B,
    0x25, 0xFC, 0x63, 0x02, 0xFD, 0x6B, 0xFD, 0x6C, 0x0D, 0x0D, 0x0D, 0x78,
    0x00, 0x05, 0x0B, 0x25, 0xFC, 0x72, 0x02, 0xFD, 0x6D, 0xFD, 0x77, 0xFE,
    0xEB, 0xFF, 0x76, 0xFF, 0xC2, 0xD0, 0x00, 0x01, 0xDB, 0x00, 0x0D, 0x88,
    0x00, 0x07, 0x18, 0xFC, 0x8F, 0x0A, 0x78, 0x00, 0x01, 0x1A, 0xFC, 0x88,
    0x81, 0xFC, 0x11, 0x18, 0xFC, 0x96, 0x01, 0xD0, 0x00, 0x0A, 0xF1, 0xFC,
    0x16, 0xC0, 0xFC, 0xA9, 0xE3, 0xFF, 0xFE, 0x58, 0x00, 0x02, 0x24, 0xFF,
    0xDE, 0x00, 0x45, 0x52, 0x52, 0x4F, 0x52, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x74, 0x72, 0x61, 0x70, 0x20, 0x61, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x6F, 0x64,
    0x65, 0x2E, 0x00, 0xDB, 0x00, 0x0D, 0x88, 0x00, 0x07, 0x0B, 0x13, 0xFC,
    0xD8, 0xFC, 0xE8, 0xFC, 0xF2, 0xFC, 0xFF, 0xFD, 0x0F, 0xFD, 0x1F, 0xFD,
    0x32, 0xFD, 0x42, 0xFD, 0x55, 0xCB, 0x00, 0x09, 0x78, 0x00, 0x02, 0xE9,
    0xFC, 0x13, 0x01, 0xCB, 0x00, 0x09, 0x78, 0x00, 0x02, 0xCD, 0x00, 0x00,
    0xE9, 0xFC, 0x13, 0x01, 0xCB, 0x00, 0x09, 0x78, 0x00, 0x02, 0xCD, 0x00,
    0x00, 0xCD, 0x00, 0x00, 0xE9, 0xFC, 0x13, 0x01, 0xCB, 0x00, 0x09, 0x78,
    0x00, 0x02, 0xCD, 0x00, 0x00, 0x6B, 0x00, 0x0B, 0xE9, 0xFC, 0x13, 0x01,
    0xCB, 0x00, 0x09, 0x78, 0x00, 0x02, 0xCD, 0x00, 0x00, 0x6B, 0x00, 0x0B,
    0xCD, 0x00, 0x00, 0xE9, 0xFC, 0x13, 0x01, 0xCB, 0x00, 0x09, 0x78, 0x00,
    0x02, 0xCD, 0x00, 0x00, 0x6B, 0x00, 0x07, 0xE9, 0xFC, 0x13, 0x01, 0xCB,
    0x00, 0x09, 0x78, 0x00, 0x02, 0xCD, 0x00, 0x00, 0x6B, 0x00, 0x07, 0x6B,
    0x00, 0x0B, 0xE9, 0xFC, 0x13, 0x01, 0xCB, 0x00, 0x09, 0x78, 0x00, 0x02,
    0xCD, 0x00, 0x00, 0x6B, 0x00, 0x0B, 0xCD, 0x00, 0x00, 0x6B, 0x00, 0x07,
    0xE9, 0xFC, 0x13, 0x01, 0x01, 0x01, 0xC0, 0x00, 0x01, 0xE1, 0xFC, 0x11,
    0x24, 0xFC, 0x7C, 0x01, 0xC0, 0x00, 0xFE, 0xE1, 0xFC, 0x11, 0x24, 0xFC,
    0x7C, 0x24, 0xFC, 0xCE, 0x58, 0x00, 0x0D, 0xC0, 0x00, 0x00, 0xE3, 0x00,
    0x06, 0xC0, 0x00, 0x00, 0xE3, 0x00, 0x02, 0xD1, 0xFC, 0x15, 0xF3, 0x00,
    0x0A, 0x80, 0x00, 0x0F, 0xE3, 0x00, 0x08, 0xD3, 0x00, 0x0A, 0xCB, 0x00,
    0x02, 0x0B, 0x13, 0xFD, 0xA8, 0xFD, 0xAE, 0xFE, 0x08, 0xFE, 0x23, 0xB0,
    0x00, 0x2B, 0x1A, 0xFD, 0xC3, 0xC8, 0x00, 0x00, 0xEB, 0x00, 0x04, 0xC8,
    0x00, 0x01, 0xEB, 0x00, 0x02, 0x12, 0xFD, 0x92, 0xB0, 0x00, 0x2D, 0x1A,
    0xFD, 0xD8, 0xC8, 0x00, 0x01, 0xEB, 0x00, 0x04, 0xC8, 0x00, 0x01, 0xEB,
    0x00, 0x02, 0x12, 0xFD, 0x92, 0xB0, 0x00, 0x30, 0x16, 0xFD, 0xF9, 0xB0,
    0x00, 0x39, 0x1E, 0xFD, 0xF9, 0xC8, 0x00, 0x00, 0xEB, 0x00, 0x04, 0xCB,
    0x00, 0x08, 0xEB, 0x00, 0x0B, 0xC8, 0x00, 0x02, 0xEB, 0x00, 0x02, 0x12,
    0xFD, 0x92, 0xB0, 0x00, 0x20, 0x18, 0xFD, 0x92, 0xB0, 0x00, 0x0A, 0x1A,
    0xFE, 0xBE, 0x12, 0xFD, 0x92, 0xB0, 0x00, 0x30, 0x16, 0xFE, 0xBE, 0xB0,
    0x00, 0x39, 0x1E, 0xFE, 0xBE, 0xCB, 0x00, 0x08, 0xEB, 0x00, 0x0B, 0xC8,
    0x00, 0x02, 0xEB, 0x00, 0x02, 0x12, 0xFD, 0x92, 0xB0, 0x00, 0x30, 0x16,
    0xFE, 0x74, 0xB0, 0x00, 0x39, 0x1E, 0xFE, 0x74, 0xC8, 0x00, 0x01, 0xC3,
    0x00, 0x0B, 0x0A, 0x20, 0xFE, 0x3C, 0x12, 0xFE, 0x3F, 0xEB, 0x00, 0x06,
    0xE3, 0x00, 0x00, 0x0A, 0x20, 0xFE, 0x49, 0x12, 0xFE, 0x4C, 0xEB, 0x00,
    0x06, 0x0A, 0x20, 0xFE, 0x53, 0x12, 0xFE, 0x56, 0xEB, 0x00, 0x06, 0x63,
    0x00, 0x00, 0x20, 0xFE, 0x5F, 0x12, 0xFE, 0x62, 0xEB, 0x00, 0x06, 0x63,
    0x00, 0x08, 0x20, 0xFE, 0x6B, 0x12, 0xFE, 0x6E, 0xEB, 0x00, 0x06, 0xE3,
    0x00, 0x0B, 0x12, 0xFD, 0x92, 0xC3, 0x00, 0x04, 0x18, 0xFE, 0x90, 0xC3,
    0x00, 0x0B, 0xA0, 0x80, 0x00, 0x18, 0xFE, 0x8A, 0x08, 0xE3, 0x00, 0x0B,
    0x12, 0xFE, 0x90, 0xC0, 0x00, 0x00, 0xE3, 0x00, 0x06, 0xDB, 0x00, 0x0F,
    0x88, 0x00, 0x01, 0xC3, 0x00, 0x0B, 0x1C, 0xFE, 0x9F, 0x98, 0x00, 0x08,
    0xA0, 0x00, 0x00, 0x1A, 0xFE, 0xA8, 0x98, 0x00, 0x04, 0xC3, 0x00, 0x06,
    0x18, 0xFE, 0xB1, 0x98, 0x00, 0x02, 0xFB, 0x00, 0x0F, 0xC3, 0x00, 0x0B,
    0xE2, 0xFC, 0x13, 0x50, 0x00, 0x0D, 0x01, 0xD0, 0x00, 0x0A, 0xF1, 0xFC,
    0x16, 0xC0, 0xFE, 0xD1, 0xE3, 0xFF, 0xFE, 0x58, 0x00, 0x02, 0x24, 0xFF,
    0xDE, 0x00, 0x45, 0x52, 0x52, 0x4F, 0x52, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x44, 0x45, 0x43, 0x49, 0x20, 0x69, 0x6E,
    0x70, 0x75, 0x74, 0x00, 0xC0, 0x00, 0xFF, 0xE1, 0xFC, 0x11, 0x24, 0xFC,
    0x7C, 0x24, 0xFC, 0xCE, 0x58, 0x00, 0x06, 0xC2, 0xFC, 0x13, 0xA0, 0x00,
    0x00, 0x1C, 0xFF, 0x0A, 0xD8, 0x00, 0x2D, 0xF9, 0xFC, 0x16, 0x08, 0xE3,
    0x00, 0x00, 0xC0, 0x00, 0x00, 0xE3, 0x00, 0x02, 0xC0, 0x27, 0x10, 0xE3,
    0x00, 0x04, 0x24, 0xFF, 0x44, 0xC0, 0x03, 0xE8, 0xE3, 0x00, 0x04, 0x24,
    0xFF, 0x44, 0xC0, 0x00, 0x64, 0xE3, 0x00, 0x04, 0x24, 0xFF, 0x44, 0xC0,
    0x00, 0x0A, 0xE3, 0x00, 0x04, 0x24, 0xFF, 0x44, 0xC3, 0x00, 0x00, 0x90,
    0x00, 0x30, 0xF1, 0xFC, 0x16, 0x50, 0x00, 0x06, 0x01, 0xC3, 0x00, 0x02,
    0xC8, 0x00, 0x00, 0x73, 0x00, 0x06, 0x16, 0xFF, 0x59, 0x68, 0x00, 0x01,
    0xE3, 0x00, 0x02, 0x12, 0xFF, 0x4A, 0xA8, 0x00, 0x00, 0x18, 0xFF, 0x68,
    0xC0, 0x00, 0x01, 0xE3, 0x00, 0x04, 0x12, 0xFF, 0x6F, 0xC3, 0x00, 0x04,
    0x1A, 0xFF, 0x6F, 0x01, 0x98, 0x00, 0x30, 0xF9, 0xFC, 0x16, 0x01, 0xC0,
    0x00, 0xFF, 0xE1, 0xFC, 0x11, 0x24, 0xFC, 0x7C, 0x24, 0xFC, 0xCE, 0xC2,
    0xFC, 0x13, 0xE1, 0xFC, 0x0F, 0xD1, 0xFC, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C,
    0x24, 0xFF, 0xA9, 0xD1, 0xFC, 0x0F, 0x24, 0xFF, 0xA9, 0xD1, 0xFC, 0x10,
    0x0C, 0x0C, 0x0C, 0x0C, 0x24, 0xFF, 0xA9, 0xD1, 0xFC, 0x10, 0x24, 0xFF,
    0xA9, 0x01, 0x80, 0x00, 0x0F, 0xB0, 0x00, 0x09, 0x14, 0xFF, 0xBB, 0x70,
    0x00, 0x09, 0x90, 0x00, 0x40, 0x12, 0xFF, 0xBE, 0x90, 0x00, 0x30, 0xF1,
    0xFC, 0x16, 0x01, 0xC0, 0x00, 0x3E, 0xE1, 0xFC, 0x11, 0x24, 0xFC, 0x7C,
    0x24, 0xFC, 0xCE, 0xC1, 0xFC, 0x13, 0xE3, 0xFF, 0xFE, 0x58, 0x00, 0x02,
    0x24, 0xFF, 0xDE, 0x50, 0x00, 0x02, 0x01, 0xC8, 0x00, 0x00, 0xC0, 0x00,
    0x00, 0xD7, 0x00, 0x02, 0x18, 0xFF, 0xF3, 0xF1, 0xFC, 0x16, 0x68, 0x00,
    0x01, 0x12, 0xFF, 0xE4, 0x01, 0xFB, 0x8F, 0xFC, 0x0F, 0xFC, 0x15, 0xFC,
    0x16, 0xFC, 0x17, 0xFC, 0x52
  };
  int err = 0;

  /* install default os if no other os has been installed */
  if (0x0000 == burn_addr) {
    err = burn(default_os, sizeof(default_os), 0xffff);
    if (err)
      return -1;
  }

  /* setup cpu registers */
  A  = 0x0000;
  X  = 0x0000;
  PC = 0x0000;
  SP = ldw(osRAM);
  IR = 0x00;
  OpSpec = 0x0000;

  return 0;
}

static int stbi(unsigned addr, char b) {
  if (addr > 0xffff)
    return -1;

  stb((word)addr, (byte)b);

  return 0;
}

static int step(void) {
  /* fetch instruction specifier */
  IR = ldb(PC);

  /* increment pc */
  PC += sizeof(byte);

  /* decode */
  /* NOOP */

  /* if non-unary */
  if (is_nonunary(IR)) {
    /* fetch operand specifier */
    OpSpec = ldw(PC);

    /* increment pc */
    PC += sizeof(word);
  }

  /* execute */
  ops[IR]();

  /* return 0 only if IR == STOP(0x0000) */
  return IR;
}

struct vm pep9 = { burn, init, stbi, step };
